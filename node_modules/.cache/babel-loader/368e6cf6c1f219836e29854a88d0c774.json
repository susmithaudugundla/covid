{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst isResumableError = require('./error').isResumableError;\n\nconst MongoError = require('./core').MongoError;\n\nconst Cursor = require('./cursor');\n\nconst relayEvents = require('./core/utils').relayEvents;\n\nconst maxWireVersion = require('./core/utils').maxWireVersion;\n\nconst maybePromise = require('./utils').maybePromise;\n\nconst AggregateOperation = require('./operations/aggregate');\n\nconst CHANGE_STREAM_OPTIONS = ['resumeAfter', 'startAfter', 'startAtOperationTime', 'fullDocument'];\nconst CURSOR_OPTIONS = ['batchSize', 'maxAwaitTimeMS', 'collation', 'readPreference'].concat(CHANGE_STREAM_OPTIONS);\nconst CHANGE_DOMAIN_TYPES = {\n  COLLECTION: Symbol('Collection'),\n  DATABASE: Symbol('Database'),\n  CLUSTER: Symbol('Cluster')\n};\n/**\n * @typedef ResumeToken\n * @description Represents the logical starting point for a new or resuming {@link ChangeStream} on the server.\n * @see https://docs.mongodb.com/master/changeStreams/#change-stream-resume-token\n */\n\n/**\n * @typedef OperationTime\n * @description Represents a specific point in time on a server. Can be retrieved by using {@link Db#command}\n * @see https://docs.mongodb.com/manual/reference/method/db.runCommand/#response\n */\n\n/**\n * @typedef ChangeStreamOptions\n * @description Options that can be passed to a ChangeStream. Note that startAfter, resumeAfter, and startAtOperationTime are all mutually exclusive, and the server will error if more than one is specified.\n * @property {string} [fullDocument='default'] Allowed values: ‘default’, ‘updateLookup’. When set to ‘updateLookup’, the change stream will include both a delta describing the changes to the document, as well as a copy of the entire document that was changed from some time after the change occurred.\n * @property {number} [maxAwaitTimeMS] The maximum amount of time for the server to wait on new documents to satisfy a change stream query.\n * @property {ResumeToken} [resumeAfter] Allows you to start a changeStream after a specified event. See {@link https://docs.mongodb.com/master/changeStreams/#resumeafter-for-change-streams|ChangeStream documentation}.\n * @property {ResumeToken} [startAfter] Similar to resumeAfter, but will allow you to start after an invalidated event. See {@link https://docs.mongodb.com/master/changeStreams/#startafter-for-change-streams|ChangeStream documentation}.\n * @property {OperationTime} [startAtOperationTime] Will start the changeStream after the specified operationTime.\n * @property {number} [batchSize=1000] The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.\n * @property {object} [collation] Specify collation settings for operation. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.\n * @property {ReadPreference} [readPreference] The read preference. Defaults to the read preference of the database or collection. See {@link https://docs.mongodb.com/manual/reference/read-preference|read preference documentation}.\n */\n\n/**\n * Creates a new Change Stream instance. Normally created using {@link Collection#watch|Collection.watch()}.\n * @class ChangeStream\n * @since 3.0.0\n * @param {(MongoClient|Db|Collection)} parent The parent object that created this change stream\n * @param {Array} pipeline An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents\n * @param {ChangeStreamOptions} [options] Optional settings\n * @fires ChangeStream#close\n * @fires ChangeStream#change\n * @fires ChangeStream#end\n * @fires ChangeStream#error\n * @fires ChangeStream#resumeTokenChanged\n * @return {ChangeStream} a ChangeStream instance.\n */\n\nclass ChangeStream extends EventEmitter {\n  constructor(parent, pipeline, options) {\n    super();\n\n    const Collection = require('./collection');\n\n    const Db = require('./db');\n\n    const MongoClient = require('./mongo_client');\n\n    this.pipeline = pipeline || [];\n    this.options = options || {};\n    this.parent = parent;\n    this.namespace = parent.s.namespace;\n\n    if (parent instanceof Collection) {\n      this.type = CHANGE_DOMAIN_TYPES.COLLECTION;\n      this.topology = parent.s.db.serverConfig;\n    } else if (parent instanceof Db) {\n      this.type = CHANGE_DOMAIN_TYPES.DATABASE;\n      this.topology = parent.serverConfig;\n    } else if (parent instanceof MongoClient) {\n      this.type = CHANGE_DOMAIN_TYPES.CLUSTER;\n      this.topology = parent.topology;\n    } else {\n      throw new TypeError('parent provided to ChangeStream constructor is not an instance of Collection, Db, or MongoClient');\n    }\n\n    this.promiseLibrary = parent.s.promiseLibrary;\n\n    if (!this.options.readPreference && parent.s.readPreference) {\n      this.options.readPreference = parent.s.readPreference;\n    } // Create contained Change Stream cursor\n\n\n    this.cursor = createChangeStreamCursor(this, options); // Listen for any `change` listeners being added to ChangeStream\n\n    this.on('newListener', eventName => {\n      if (eventName === 'change' && this.cursor && this.listenerCount('change') === 0) {\n        this.cursor.on('data', change => processNewChange({\n          changeStream: this,\n          change,\n          eventEmitter: true\n        }));\n      }\n    }); // Listen for all `change` listeners being removed from ChangeStream\n\n    this.on('removeListener', eventName => {\n      if (eventName === 'change' && this.listenerCount('change') === 0 && this.cursor) {\n        this.cursor.removeAllListeners('data');\n      }\n    });\n  }\n  /**\n   * @property {ResumeToken} resumeToken\n   * The cached resume token that will be used to resume\n   * after the most recently returned change.\n   */\n\n\n  get resumeToken() {\n    return this.cursor.resumeToken;\n  }\n  /**\n   * Check if there is any document still available in the Change Stream\n   * @function ChangeStream.prototype.hasNext\n   * @param {ChangeStream~resultCallback} [callback] The result callback.\n   * @throws {MongoError}\n   * @returns {Promise|void} returns Promise if no callback passed\n   */\n\n\n  hasNext(callback) {\n    return maybePromise(this.parent, callback, cb => this.cursor.hasNext(cb));\n  }\n  /**\n   * Get the next available document from the Change Stream, returns null if no more documents are available.\n   * @function ChangeStream.prototype.next\n   * @param {ChangeStream~resultCallback} [callback] The result callback.\n   * @throws {MongoError}\n   * @returns {Promise|void} returns Promise if no callback passed\n   */\n\n\n  next(callback) {\n    return maybePromise(this.parent, callback, cb => {\n      if (this.isClosed()) {\n        return cb(new Error('Change Stream is not open.'));\n      }\n\n      this.cursor.next((error, change) => {\n        processNewChange({\n          changeStream: this,\n          error,\n          change,\n          callback: cb\n        });\n      });\n    });\n  }\n  /**\n   * Is the cursor closed\n   * @method ChangeStream.prototype.isClosed\n   * @return {boolean}\n   */\n\n\n  isClosed() {\n    if (this.cursor) {\n      return this.cursor.isClosed();\n    }\n\n    return true;\n  }\n  /**\n   * Close the Change Stream\n   * @method ChangeStream.prototype.close\n   * @param {ChangeStream~resultCallback} [callback] The result callback.\n   * @return {Promise} returns Promise if no callback passed\n   */\n\n\n  close(callback) {\n    if (!this.cursor) {\n      if (callback) return callback();\n      return this.promiseLibrary.resolve();\n    } // Tidy up the existing cursor\n\n\n    const cursor = this.cursor;\n\n    if (callback) {\n      return cursor.close(err => {\n        ['data', 'close', 'end', 'error'].forEach(event => cursor.removeAllListeners(event));\n        delete this.cursor;\n        return callback(err);\n      });\n    }\n\n    const PromiseCtor = this.promiseLibrary || Promise;\n    return new PromiseCtor((resolve, reject) => {\n      cursor.close(err => {\n        ['data', 'close', 'end', 'error'].forEach(event => cursor.removeAllListeners(event));\n        delete this.cursor;\n        if (err) return reject(err);\n        resolve();\n      });\n    });\n  }\n  /**\n   * This method pulls all the data out of a readable stream, and writes it to the supplied destination, automatically managing the flow so that the destination is not overwhelmed by a fast readable stream.\n   * @method\n   * @param {Writable} destination The destination for writing data\n   * @param {object} [options] {@link https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options|Pipe options}\n   * @return {null}\n   */\n\n\n  pipe(destination, options) {\n    if (!this.pipeDestinations) {\n      this.pipeDestinations = [];\n    }\n\n    this.pipeDestinations.push(destination);\n    return this.cursor.pipe(destination, options);\n  }\n  /**\n   * This method will remove the hooks set up for a previous pipe() call.\n   * @param {Writable} [destination] The destination for writing data\n   * @return {null}\n   */\n\n\n  unpipe(destination) {\n    if (this.pipeDestinations && this.pipeDestinations.indexOf(destination) > -1) {\n      this.pipeDestinations.splice(this.pipeDestinations.indexOf(destination), 1);\n    }\n\n    return this.cursor.unpipe(destination);\n  }\n  /**\n   * Return a modified Readable stream including a possible transform method.\n   * @method\n   * @param {object} [options] Optional settings.\n   * @param {function} [options.transform] A transformation method applied to each document emitted by the stream.\n   * @return {Cursor}\n   */\n\n\n  stream(options) {\n    this.streamOptions = options;\n    return this.cursor.stream(options);\n  }\n  /**\n   * This method will cause a stream in flowing mode to stop emitting data events. Any data that becomes available will remain in the internal buffer.\n   * @return {null}\n   */\n\n\n  pause() {\n    return this.cursor.pause();\n  }\n  /**\n   * This method will cause the readable stream to resume emitting data events.\n   * @return {null}\n   */\n\n\n  resume() {\n    return this.cursor.resume();\n  }\n\n}\n\nclass ChangeStreamCursor extends Cursor {\n  constructor(topology, operation, options) {\n    super(topology, operation, options);\n    options = options || {};\n    this._resumeToken = null;\n    this.startAtOperationTime = options.startAtOperationTime;\n\n    if (options.startAfter) {\n      this.resumeToken = options.startAfter;\n    } else if (options.resumeAfter) {\n      this.resumeToken = options.resumeAfter;\n    }\n  }\n\n  set resumeToken(token) {\n    this._resumeToken = token;\n    this.emit('resumeTokenChanged', token);\n  }\n\n  get resumeToken() {\n    return this._resumeToken;\n  }\n\n  get resumeOptions() {\n    const result = {};\n\n    for (const optionName of CURSOR_OPTIONS) {\n      if (this.options[optionName]) result[optionName] = this.options[optionName];\n    }\n\n    if (this.resumeToken || this.startAtOperationTime) {\n      ['resumeAfter', 'startAfter', 'startAtOperationTime'].forEach(key => delete result[key]);\n\n      if (this.resumeToken) {\n        result.resumeAfter = this.resumeToken;\n      } else if (this.startAtOperationTime && maxWireVersion(this.server) >= 7) {\n        result.startAtOperationTime = this.startAtOperationTime;\n      }\n    }\n\n    return result;\n  }\n\n  _initializeCursor(callback) {\n    super._initializeCursor((err, result) => {\n      if (err) {\n        callback(err, null);\n        return;\n      }\n\n      const response = result.documents[0];\n\n      if (this.startAtOperationTime == null && this.resumeAfter == null && this.startAfter == null && maxWireVersion(this.server) >= 7) {\n        this.startAtOperationTime = response.operationTime;\n      }\n\n      const cursor = response.cursor;\n\n      if (cursor.postBatchResumeToken) {\n        this.cursorState.postBatchResumeToken = cursor.postBatchResumeToken;\n\n        if (cursor.firstBatch.length === 0) {\n          this.resumeToken = cursor.postBatchResumeToken;\n        }\n      }\n\n      this.emit('response');\n      callback(err, result);\n    });\n  }\n\n  _getMore(callback) {\n    super._getMore((err, response) => {\n      if (err) {\n        callback(err, null);\n        return;\n      }\n\n      const cursor = response.cursor;\n\n      if (cursor.postBatchResumeToken) {\n        this.cursorState.postBatchResumeToken = cursor.postBatchResumeToken;\n\n        if (cursor.nextBatch.length === 0) {\n          this.resumeToken = cursor.postBatchResumeToken;\n        }\n      }\n\n      this.emit('response');\n      callback(err, response);\n    });\n  }\n\n}\n/**\n * @event ChangeStreamCursor#response\n * internal event DO NOT USE\n * @ignore\n */\n// Create a new change stream cursor based on self's configuration\n\n\nfunction createChangeStreamCursor(self, options) {\n  const changeStreamStageOptions = {\n    fullDocument: options.fullDocument || 'default'\n  };\n  applyKnownOptions(changeStreamStageOptions, options, CHANGE_STREAM_OPTIONS);\n\n  if (self.type === CHANGE_DOMAIN_TYPES.CLUSTER) {\n    changeStreamStageOptions.allChangesForCluster = true;\n  }\n\n  const pipeline = [{\n    $changeStream: changeStreamStageOptions\n  }].concat(self.pipeline);\n  const cursorOptions = applyKnownOptions({}, options, CURSOR_OPTIONS);\n  const changeStreamCursor = new ChangeStreamCursor(self.topology, new AggregateOperation(self.parent, pipeline, options), cursorOptions);\n  relayEvents(changeStreamCursor, self, ['resumeTokenChanged', 'end', 'close']);\n  /**\n   * Fired for each new matching change in the specified namespace. Attaching a `change`\n   * event listener to a Change Stream will switch the stream into flowing mode. Data will\n   * then be passed as soon as it is available.\n   *\n   * @event ChangeStream#change\n   * @type {object}\n   */\n\n  if (self.listenerCount('change') > 0) {\n    changeStreamCursor.on('data', function (change) {\n      processNewChange({\n        changeStream: self,\n        change,\n        eventEmitter: true\n      });\n    });\n  }\n  /**\n   * Change stream close event\n   *\n   * @event ChangeStream#close\n   * @type {null}\n   */\n\n  /**\n   * Change stream end event\n   *\n   * @event ChangeStream#end\n   * @type {null}\n   */\n\n  /**\n   * Emitted each time the change stream stores a new resume token.\n   *\n   * @event ChangeStream#resumeTokenChanged\n   * @type {ResumeToken}\n   */\n\n  /**\n   * Fired when the stream encounters an error.\n   *\n   * @event ChangeStream#error\n   * @type {Error}\n   */\n\n\n  changeStreamCursor.on('error', function (error) {\n    processNewChange({\n      changeStream: self,\n      error,\n      eventEmitter: true\n    });\n  });\n\n  if (self.pipeDestinations) {\n    const cursorStream = changeStreamCursor.stream(self.streamOptions);\n\n    for (let pipeDestination in self.pipeDestinations) {\n      cursorStream.pipe(pipeDestination);\n    }\n  }\n\n  return changeStreamCursor;\n}\n\nfunction applyKnownOptions(target, source, optionNames) {\n  optionNames.forEach(name => {\n    if (source[name]) {\n      target[name] = source[name];\n    }\n  });\n  return target;\n} // This method performs a basic server selection loop, satisfying the requirements of\n// ChangeStream resumability until the new SDAM layer can be used.\n\n\nconst SELECTION_TIMEOUT = 30000;\n\nfunction waitForTopologyConnected(topology, options, callback) {\n  setTimeout(() => {\n    if (options && options.start == null) options.start = process.hrtime();\n    const start = options.start || process.hrtime();\n    const timeout = options.timeout || SELECTION_TIMEOUT;\n    const readPreference = options.readPreference;\n    if (topology.isConnected({\n      readPreference\n    })) return callback(null, null);\n    const hrElapsed = process.hrtime(start);\n    const elapsed = (hrElapsed[0] * 1e9 + hrElapsed[1]) / 1e6;\n    if (elapsed > timeout) return callback(new MongoError('Timed out waiting for connection'));\n    waitForTopologyConnected(topology, options, callback);\n  }, 3000); // this is an arbitrary wait time to allow SDAM to transition\n} // Handle new change events. This method brings together the routes from the callback, event emitter, and promise ways of using ChangeStream.\n\n\nfunction processNewChange(args) {\n  const changeStream = args.changeStream;\n  const error = args.error;\n  const change = args.change;\n  const callback = args.callback;\n  const eventEmitter = args.eventEmitter || false; // If the changeStream is closed, then it should not process a change.\n\n  if (changeStream.isClosed()) {\n    // We do not error in the eventEmitter case.\n    if (eventEmitter) {\n      return;\n    }\n\n    const error = new MongoError('ChangeStream is closed');\n    return typeof callback === 'function' ? callback(error, null) : changeStream.promiseLibrary.reject(error);\n  }\n\n  const cursor = changeStream.cursor;\n  const topology = changeStream.topology;\n  const options = changeStream.cursor.options;\n\n  if (error) {\n    if (isResumableError(error) && !changeStream.attemptingResume) {\n      changeStream.attemptingResume = true; // stop listening to all events from old cursor\n\n      ['data', 'close', 'end', 'error'].forEach(event => changeStream.cursor.removeAllListeners(event)); // close internal cursor, ignore errors\n\n      changeStream.cursor.close(); // attempt recreating the cursor\n\n      if (eventEmitter) {\n        waitForTopologyConnected(topology, {\n          readPreference: options.readPreference\n        }, err => {\n          if (err) {\n            changeStream.emit('error', err);\n            changeStream.emit('close');\n            return;\n          }\n\n          changeStream.cursor = createChangeStreamCursor(changeStream, cursor.resumeOptions);\n        });\n        return;\n      }\n\n      if (callback) {\n        waitForTopologyConnected(topology, {\n          readPreference: options.readPreference\n        }, err => {\n          if (err) return callback(err, null);\n          changeStream.cursor = createChangeStreamCursor(changeStream, cursor.resumeOptions);\n          changeStream.next(callback);\n        });\n        return;\n      }\n\n      return new Promise((resolve, reject) => {\n        waitForTopologyConnected(topology, {\n          readPreference: options.readPreference\n        }, err => {\n          if (err) return reject(err);\n          resolve();\n        });\n      }).then(() => changeStream.cursor = createChangeStreamCursor(changeStream, cursor.resumeOptions)).then(() => changeStream.next());\n    }\n\n    if (eventEmitter) return changeStream.emit('error', error);\n    if (typeof callback === 'function') return callback(error, null);\n    return changeStream.promiseLibrary.reject(error);\n  }\n\n  changeStream.attemptingResume = false;\n\n  if (change && !change._id) {\n    const noResumeTokenError = new Error('A change stream document has been received that lacks a resume token (_id).');\n    if (eventEmitter) return changeStream.emit('error', noResumeTokenError);\n    if (typeof callback === 'function') return callback(noResumeTokenError, null);\n    return changeStream.promiseLibrary.reject(noResumeTokenError);\n  } // cache the resume token\n\n\n  if (cursor.bufferedCount() === 0 && cursor.cursorState.postBatchResumeToken) {\n    cursor.resumeToken = cursor.cursorState.postBatchResumeToken;\n  } else {\n    cursor.resumeToken = change._id;\n  } // wipe the startAtOperationTime if there was one so that there won't be a conflict\n  // between resumeToken and startAtOperationTime if we need to reconnect the cursor\n\n\n  changeStream.options.startAtOperationTime = undefined; // Return the change\n\n  if (eventEmitter) return changeStream.emit('change', change);\n  if (typeof callback === 'function') return callback(error, change);\n  return changeStream.promiseLibrary.resolve(change);\n}\n/**\n * The callback format for results\n * @callback ChangeStream~resultCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {(object|null)} result The result object if the command was executed successfully.\n */\n\n\nmodule.exports = ChangeStream;","map":{"version":3,"sources":["/home/rgukt/Projects/covid-19/node_modules/mongodb/lib/change_stream.js"],"names":["EventEmitter","require","isResumableError","MongoError","Cursor","relayEvents","maxWireVersion","maybePromise","AggregateOperation","CHANGE_STREAM_OPTIONS","CURSOR_OPTIONS","concat","CHANGE_DOMAIN_TYPES","COLLECTION","Symbol","DATABASE","CLUSTER","ChangeStream","constructor","parent","pipeline","options","Collection","Db","MongoClient","namespace","s","type","topology","db","serverConfig","TypeError","promiseLibrary","readPreference","cursor","createChangeStreamCursor","on","eventName","listenerCount","change","processNewChange","changeStream","eventEmitter","removeAllListeners","resumeToken","hasNext","callback","cb","next","isClosed","Error","error","close","resolve","err","forEach","event","PromiseCtor","Promise","reject","pipe","destination","pipeDestinations","push","unpipe","indexOf","splice","stream","streamOptions","pause","resume","ChangeStreamCursor","operation","_resumeToken","startAtOperationTime","startAfter","resumeAfter","token","emit","resumeOptions","result","optionName","key","server","_initializeCursor","response","documents","operationTime","postBatchResumeToken","cursorState","firstBatch","length","_getMore","nextBatch","self","changeStreamStageOptions","fullDocument","applyKnownOptions","allChangesForCluster","$changeStream","cursorOptions","changeStreamCursor","cursorStream","pipeDestination","target","source","optionNames","name","SELECTION_TIMEOUT","waitForTopologyConnected","setTimeout","start","process","hrtime","timeout","isConnected","hrElapsed","elapsed","args","attemptingResume","then","_id","noResumeTokenError","bufferedCount","undefined","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst EventEmitter = require('events');\nconst isResumableError = require('./error').isResumableError;\nconst MongoError = require('./core').MongoError;\nconst Cursor = require('./cursor');\nconst relayEvents = require('./core/utils').relayEvents;\nconst maxWireVersion = require('./core/utils').maxWireVersion;\nconst maybePromise = require('./utils').maybePromise;\nconst AggregateOperation = require('./operations/aggregate');\n\nconst CHANGE_STREAM_OPTIONS = ['resumeAfter', 'startAfter', 'startAtOperationTime', 'fullDocument'];\nconst CURSOR_OPTIONS = ['batchSize', 'maxAwaitTimeMS', 'collation', 'readPreference'].concat(\n  CHANGE_STREAM_OPTIONS\n);\n\nconst CHANGE_DOMAIN_TYPES = {\n  COLLECTION: Symbol('Collection'),\n  DATABASE: Symbol('Database'),\n  CLUSTER: Symbol('Cluster')\n};\n\n/**\n * @typedef ResumeToken\n * @description Represents the logical starting point for a new or resuming {@link ChangeStream} on the server.\n * @see https://docs.mongodb.com/master/changeStreams/#change-stream-resume-token\n */\n\n/**\n * @typedef OperationTime\n * @description Represents a specific point in time on a server. Can be retrieved by using {@link Db#command}\n * @see https://docs.mongodb.com/manual/reference/method/db.runCommand/#response\n */\n\n/**\n * @typedef ChangeStreamOptions\n * @description Options that can be passed to a ChangeStream. Note that startAfter, resumeAfter, and startAtOperationTime are all mutually exclusive, and the server will error if more than one is specified.\n * @property {string} [fullDocument='default'] Allowed values: ‘default’, ‘updateLookup’. When set to ‘updateLookup’, the change stream will include both a delta describing the changes to the document, as well as a copy of the entire document that was changed from some time after the change occurred.\n * @property {number} [maxAwaitTimeMS] The maximum amount of time for the server to wait on new documents to satisfy a change stream query.\n * @property {ResumeToken} [resumeAfter] Allows you to start a changeStream after a specified event. See {@link https://docs.mongodb.com/master/changeStreams/#resumeafter-for-change-streams|ChangeStream documentation}.\n * @property {ResumeToken} [startAfter] Similar to resumeAfter, but will allow you to start after an invalidated event. See {@link https://docs.mongodb.com/master/changeStreams/#startafter-for-change-streams|ChangeStream documentation}.\n * @property {OperationTime} [startAtOperationTime] Will start the changeStream after the specified operationTime.\n * @property {number} [batchSize=1000] The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.\n * @property {object} [collation] Specify collation settings for operation. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.\n * @property {ReadPreference} [readPreference] The read preference. Defaults to the read preference of the database or collection. See {@link https://docs.mongodb.com/manual/reference/read-preference|read preference documentation}.\n */\n\n/**\n * Creates a new Change Stream instance. Normally created using {@link Collection#watch|Collection.watch()}.\n * @class ChangeStream\n * @since 3.0.0\n * @param {(MongoClient|Db|Collection)} parent The parent object that created this change stream\n * @param {Array} pipeline An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents\n * @param {ChangeStreamOptions} [options] Optional settings\n * @fires ChangeStream#close\n * @fires ChangeStream#change\n * @fires ChangeStream#end\n * @fires ChangeStream#error\n * @fires ChangeStream#resumeTokenChanged\n * @return {ChangeStream} a ChangeStream instance.\n */\nclass ChangeStream extends EventEmitter {\n  constructor(parent, pipeline, options) {\n    super();\n    const Collection = require('./collection');\n    const Db = require('./db');\n    const MongoClient = require('./mongo_client');\n\n    this.pipeline = pipeline || [];\n    this.options = options || {};\n\n    this.parent = parent;\n    this.namespace = parent.s.namespace;\n    if (parent instanceof Collection) {\n      this.type = CHANGE_DOMAIN_TYPES.COLLECTION;\n      this.topology = parent.s.db.serverConfig;\n    } else if (parent instanceof Db) {\n      this.type = CHANGE_DOMAIN_TYPES.DATABASE;\n      this.topology = parent.serverConfig;\n    } else if (parent instanceof MongoClient) {\n      this.type = CHANGE_DOMAIN_TYPES.CLUSTER;\n      this.topology = parent.topology;\n    } else {\n      throw new TypeError(\n        'parent provided to ChangeStream constructor is not an instance of Collection, Db, or MongoClient'\n      );\n    }\n\n    this.promiseLibrary = parent.s.promiseLibrary;\n    if (!this.options.readPreference && parent.s.readPreference) {\n      this.options.readPreference = parent.s.readPreference;\n    }\n\n    // Create contained Change Stream cursor\n    this.cursor = createChangeStreamCursor(this, options);\n\n    // Listen for any `change` listeners being added to ChangeStream\n    this.on('newListener', eventName => {\n      if (eventName === 'change' && this.cursor && this.listenerCount('change') === 0) {\n        this.cursor.on('data', change =>\n          processNewChange({ changeStream: this, change, eventEmitter: true })\n        );\n      }\n    });\n\n    // Listen for all `change` listeners being removed from ChangeStream\n    this.on('removeListener', eventName => {\n      if (eventName === 'change' && this.listenerCount('change') === 0 && this.cursor) {\n        this.cursor.removeAllListeners('data');\n      }\n    });\n  }\n\n  /**\n   * @property {ResumeToken} resumeToken\n   * The cached resume token that will be used to resume\n   * after the most recently returned change.\n   */\n  get resumeToken() {\n    return this.cursor.resumeToken;\n  }\n\n  /**\n   * Check if there is any document still available in the Change Stream\n   * @function ChangeStream.prototype.hasNext\n   * @param {ChangeStream~resultCallback} [callback] The result callback.\n   * @throws {MongoError}\n   * @returns {Promise|void} returns Promise if no callback passed\n   */\n  hasNext(callback) {\n    return maybePromise(this.parent, callback, cb => this.cursor.hasNext(cb));\n  }\n\n  /**\n   * Get the next available document from the Change Stream, returns null if no more documents are available.\n   * @function ChangeStream.prototype.next\n   * @param {ChangeStream~resultCallback} [callback] The result callback.\n   * @throws {MongoError}\n   * @returns {Promise|void} returns Promise if no callback passed\n   */\n  next(callback) {\n    return maybePromise(this.parent, callback, cb => {\n      if (this.isClosed()) {\n        return cb(new Error('Change Stream is not open.'));\n      }\n      this.cursor.next((error, change) => {\n        processNewChange({ changeStream: this, error, change, callback: cb });\n      });\n    });\n  }\n\n  /**\n   * Is the cursor closed\n   * @method ChangeStream.prototype.isClosed\n   * @return {boolean}\n   */\n  isClosed() {\n    if (this.cursor) {\n      return this.cursor.isClosed();\n    }\n    return true;\n  }\n\n  /**\n   * Close the Change Stream\n   * @method ChangeStream.prototype.close\n   * @param {ChangeStream~resultCallback} [callback] The result callback.\n   * @return {Promise} returns Promise if no callback passed\n   */\n  close(callback) {\n    if (!this.cursor) {\n      if (callback) return callback();\n      return this.promiseLibrary.resolve();\n    }\n\n    // Tidy up the existing cursor\n    const cursor = this.cursor;\n\n    if (callback) {\n      return cursor.close(err => {\n        ['data', 'close', 'end', 'error'].forEach(event => cursor.removeAllListeners(event));\n        delete this.cursor;\n\n        return callback(err);\n      });\n    }\n\n    const PromiseCtor = this.promiseLibrary || Promise;\n    return new PromiseCtor((resolve, reject) => {\n      cursor.close(err => {\n        ['data', 'close', 'end', 'error'].forEach(event => cursor.removeAllListeners(event));\n        delete this.cursor;\n\n        if (err) return reject(err);\n        resolve();\n      });\n    });\n  }\n\n  /**\n   * This method pulls all the data out of a readable stream, and writes it to the supplied destination, automatically managing the flow so that the destination is not overwhelmed by a fast readable stream.\n   * @method\n   * @param {Writable} destination The destination for writing data\n   * @param {object} [options] {@link https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options|Pipe options}\n   * @return {null}\n   */\n  pipe(destination, options) {\n    if (!this.pipeDestinations) {\n      this.pipeDestinations = [];\n    }\n    this.pipeDestinations.push(destination);\n    return this.cursor.pipe(destination, options);\n  }\n\n  /**\n   * This method will remove the hooks set up for a previous pipe() call.\n   * @param {Writable} [destination] The destination for writing data\n   * @return {null}\n   */\n  unpipe(destination) {\n    if (this.pipeDestinations && this.pipeDestinations.indexOf(destination) > -1) {\n      this.pipeDestinations.splice(this.pipeDestinations.indexOf(destination), 1);\n    }\n    return this.cursor.unpipe(destination);\n  }\n\n  /**\n   * Return a modified Readable stream including a possible transform method.\n   * @method\n   * @param {object} [options] Optional settings.\n   * @param {function} [options.transform] A transformation method applied to each document emitted by the stream.\n   * @return {Cursor}\n   */\n  stream(options) {\n    this.streamOptions = options;\n    return this.cursor.stream(options);\n  }\n\n  /**\n   * This method will cause a stream in flowing mode to stop emitting data events. Any data that becomes available will remain in the internal buffer.\n   * @return {null}\n   */\n  pause() {\n    return this.cursor.pause();\n  }\n\n  /**\n   * This method will cause the readable stream to resume emitting data events.\n   * @return {null}\n   */\n  resume() {\n    return this.cursor.resume();\n  }\n}\n\nclass ChangeStreamCursor extends Cursor {\n  constructor(topology, operation, options) {\n    super(topology, operation, options);\n\n    options = options || {};\n    this._resumeToken = null;\n    this.startAtOperationTime = options.startAtOperationTime;\n\n    if (options.startAfter) {\n      this.resumeToken = options.startAfter;\n    } else if (options.resumeAfter) {\n      this.resumeToken = options.resumeAfter;\n    }\n  }\n\n  set resumeToken(token) {\n    this._resumeToken = token;\n    this.emit('resumeTokenChanged', token);\n  }\n\n  get resumeToken() {\n    return this._resumeToken;\n  }\n\n  get resumeOptions() {\n    const result = {};\n    for (const optionName of CURSOR_OPTIONS) {\n      if (this.options[optionName]) result[optionName] = this.options[optionName];\n    }\n\n    if (this.resumeToken || this.startAtOperationTime) {\n      ['resumeAfter', 'startAfter', 'startAtOperationTime'].forEach(key => delete result[key]);\n\n      if (this.resumeToken) {\n        result.resumeAfter = this.resumeToken;\n      } else if (this.startAtOperationTime && maxWireVersion(this.server) >= 7) {\n        result.startAtOperationTime = this.startAtOperationTime;\n      }\n    }\n\n    return result;\n  }\n\n  _initializeCursor(callback) {\n    super._initializeCursor((err, result) => {\n      if (err) {\n        callback(err, null);\n        return;\n      }\n\n      const response = result.documents[0];\n\n      if (\n        this.startAtOperationTime == null &&\n        this.resumeAfter == null &&\n        this.startAfter == null &&\n        maxWireVersion(this.server) >= 7\n      ) {\n        this.startAtOperationTime = response.operationTime;\n      }\n\n      const cursor = response.cursor;\n      if (cursor.postBatchResumeToken) {\n        this.cursorState.postBatchResumeToken = cursor.postBatchResumeToken;\n\n        if (cursor.firstBatch.length === 0) {\n          this.resumeToken = cursor.postBatchResumeToken;\n        }\n      }\n\n      this.emit('response');\n      callback(err, result);\n    });\n  }\n\n  _getMore(callback) {\n    super._getMore((err, response) => {\n      if (err) {\n        callback(err, null);\n        return;\n      }\n\n      const cursor = response.cursor;\n      if (cursor.postBatchResumeToken) {\n        this.cursorState.postBatchResumeToken = cursor.postBatchResumeToken;\n\n        if (cursor.nextBatch.length === 0) {\n          this.resumeToken = cursor.postBatchResumeToken;\n        }\n      }\n\n      this.emit('response');\n      callback(err, response);\n    });\n  }\n}\n\n/**\n * @event ChangeStreamCursor#response\n * internal event DO NOT USE\n * @ignore\n */\n\n// Create a new change stream cursor based on self's configuration\nfunction createChangeStreamCursor(self, options) {\n  const changeStreamStageOptions = { fullDocument: options.fullDocument || 'default' };\n  applyKnownOptions(changeStreamStageOptions, options, CHANGE_STREAM_OPTIONS);\n  if (self.type === CHANGE_DOMAIN_TYPES.CLUSTER) {\n    changeStreamStageOptions.allChangesForCluster = true;\n  }\n\n  const pipeline = [{ $changeStream: changeStreamStageOptions }].concat(self.pipeline);\n  const cursorOptions = applyKnownOptions({}, options, CURSOR_OPTIONS);\n  const changeStreamCursor = new ChangeStreamCursor(\n    self.topology,\n    new AggregateOperation(self.parent, pipeline, options),\n    cursorOptions\n  );\n\n  relayEvents(changeStreamCursor, self, ['resumeTokenChanged', 'end', 'close']);\n\n  /**\n   * Fired for each new matching change in the specified namespace. Attaching a `change`\n   * event listener to a Change Stream will switch the stream into flowing mode. Data will\n   * then be passed as soon as it is available.\n   *\n   * @event ChangeStream#change\n   * @type {object}\n   */\n  if (self.listenerCount('change') > 0) {\n    changeStreamCursor.on('data', function(change) {\n      processNewChange({ changeStream: self, change, eventEmitter: true });\n    });\n  }\n\n  /**\n   * Change stream close event\n   *\n   * @event ChangeStream#close\n   * @type {null}\n   */\n\n  /**\n   * Change stream end event\n   *\n   * @event ChangeStream#end\n   * @type {null}\n   */\n\n  /**\n   * Emitted each time the change stream stores a new resume token.\n   *\n   * @event ChangeStream#resumeTokenChanged\n   * @type {ResumeToken}\n   */\n\n  /**\n   * Fired when the stream encounters an error.\n   *\n   * @event ChangeStream#error\n   * @type {Error}\n   */\n  changeStreamCursor.on('error', function(error) {\n    processNewChange({ changeStream: self, error, eventEmitter: true });\n  });\n\n  if (self.pipeDestinations) {\n    const cursorStream = changeStreamCursor.stream(self.streamOptions);\n    for (let pipeDestination in self.pipeDestinations) {\n      cursorStream.pipe(pipeDestination);\n    }\n  }\n\n  return changeStreamCursor;\n}\n\nfunction applyKnownOptions(target, source, optionNames) {\n  optionNames.forEach(name => {\n    if (source[name]) {\n      target[name] = source[name];\n    }\n  });\n\n  return target;\n}\n\n// This method performs a basic server selection loop, satisfying the requirements of\n// ChangeStream resumability until the new SDAM layer can be used.\nconst SELECTION_TIMEOUT = 30000;\nfunction waitForTopologyConnected(topology, options, callback) {\n  setTimeout(() => {\n    if (options && options.start == null) options.start = process.hrtime();\n    const start = options.start || process.hrtime();\n    const timeout = options.timeout || SELECTION_TIMEOUT;\n    const readPreference = options.readPreference;\n\n    if (topology.isConnected({ readPreference })) return callback(null, null);\n    const hrElapsed = process.hrtime(start);\n    const elapsed = (hrElapsed[0] * 1e9 + hrElapsed[1]) / 1e6;\n    if (elapsed > timeout) return callback(new MongoError('Timed out waiting for connection'));\n    waitForTopologyConnected(topology, options, callback);\n  }, 3000); // this is an arbitrary wait time to allow SDAM to transition\n}\n\n// Handle new change events. This method brings together the routes from the callback, event emitter, and promise ways of using ChangeStream.\nfunction processNewChange(args) {\n  const changeStream = args.changeStream;\n  const error = args.error;\n  const change = args.change;\n  const callback = args.callback;\n  const eventEmitter = args.eventEmitter || false;\n\n  // If the changeStream is closed, then it should not process a change.\n  if (changeStream.isClosed()) {\n    // We do not error in the eventEmitter case.\n    if (eventEmitter) {\n      return;\n    }\n\n    const error = new MongoError('ChangeStream is closed');\n    return typeof callback === 'function'\n      ? callback(error, null)\n      : changeStream.promiseLibrary.reject(error);\n  }\n\n  const cursor = changeStream.cursor;\n  const topology = changeStream.topology;\n  const options = changeStream.cursor.options;\n\n  if (error) {\n    if (isResumableError(error) && !changeStream.attemptingResume) {\n      changeStream.attemptingResume = true;\n\n      // stop listening to all events from old cursor\n      ['data', 'close', 'end', 'error'].forEach(event =>\n        changeStream.cursor.removeAllListeners(event)\n      );\n\n      // close internal cursor, ignore errors\n      changeStream.cursor.close();\n\n      // attempt recreating the cursor\n      if (eventEmitter) {\n        waitForTopologyConnected(topology, { readPreference: options.readPreference }, err => {\n          if (err) {\n            changeStream.emit('error', err);\n            changeStream.emit('close');\n            return;\n          }\n          changeStream.cursor = createChangeStreamCursor(changeStream, cursor.resumeOptions);\n        });\n\n        return;\n      }\n\n      if (callback) {\n        waitForTopologyConnected(topology, { readPreference: options.readPreference }, err => {\n          if (err) return callback(err, null);\n\n          changeStream.cursor = createChangeStreamCursor(changeStream, cursor.resumeOptions);\n          changeStream.next(callback);\n        });\n\n        return;\n      }\n\n      return new Promise((resolve, reject) => {\n        waitForTopologyConnected(topology, { readPreference: options.readPreference }, err => {\n          if (err) return reject(err);\n          resolve();\n        });\n      })\n        .then(\n          () => (changeStream.cursor = createChangeStreamCursor(changeStream, cursor.resumeOptions))\n        )\n        .then(() => changeStream.next());\n    }\n\n    if (eventEmitter) return changeStream.emit('error', error);\n    if (typeof callback === 'function') return callback(error, null);\n    return changeStream.promiseLibrary.reject(error);\n  }\n\n  changeStream.attemptingResume = false;\n\n  if (change && !change._id) {\n    const noResumeTokenError = new Error(\n      'A change stream document has been received that lacks a resume token (_id).'\n    );\n\n    if (eventEmitter) return changeStream.emit('error', noResumeTokenError);\n    if (typeof callback === 'function') return callback(noResumeTokenError, null);\n    return changeStream.promiseLibrary.reject(noResumeTokenError);\n  }\n\n  // cache the resume token\n  if (cursor.bufferedCount() === 0 && cursor.cursorState.postBatchResumeToken) {\n    cursor.resumeToken = cursor.cursorState.postBatchResumeToken;\n  } else {\n    cursor.resumeToken = change._id;\n  }\n\n  // wipe the startAtOperationTime if there was one so that there won't be a conflict\n  // between resumeToken and startAtOperationTime if we need to reconnect the cursor\n  changeStream.options.startAtOperationTime = undefined;\n\n  // Return the change\n  if (eventEmitter) return changeStream.emit('change', change);\n  if (typeof callback === 'function') return callback(error, change);\n  return changeStream.promiseLibrary.resolve(change);\n}\n\n/**\n * The callback format for results\n * @callback ChangeStream~resultCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {(object|null)} result The result object if the command was executed successfully.\n */\n\nmodule.exports = ChangeStream;\n"]},"metadata":{},"sourceType":"script"}