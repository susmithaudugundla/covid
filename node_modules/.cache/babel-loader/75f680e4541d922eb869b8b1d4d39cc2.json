{"ast":null,"code":"'use strict';\n\nconst ServerType = require('./common').ServerType;\n\nconst calculateDurationInMs = require('../utils').calculateDurationInMs;\n\nconst EventEmitter = require('events');\n\nconst connect = require('../connection/connect');\n\nconst Connection = require('../../cmap/connection').Connection;\n\nconst common = require('./common');\n\nconst makeStateMachine = require('../utils').makeStateMachine;\n\nconst MongoError = require('../error').MongoError;\n\nconst sdamEvents = require('./events');\n\nconst ServerHeartbeatStartedEvent = sdamEvents.ServerHeartbeatStartedEvent;\nconst ServerHeartbeatSucceededEvent = sdamEvents.ServerHeartbeatSucceededEvent;\nconst ServerHeartbeatFailedEvent = sdamEvents.ServerHeartbeatFailedEvent;\nconst kServer = Symbol('server');\nconst kMonitorId = Symbol('monitorId');\nconst kConnection = Symbol('connection');\nconst kCancellationToken = Symbol('cancellationToken');\nconst kLastCheckTime = Symbol('lastCheckTime');\nconst STATE_CLOSED = common.STATE_CLOSED;\nconst STATE_CLOSING = common.STATE_CLOSING;\nconst STATE_IDLE = 'idle';\nconst STATE_MONITORING = 'monitoring';\nconst stateTransition = makeStateMachine({\n  [STATE_CLOSING]: [STATE_CLOSING, STATE_CLOSED],\n  [STATE_CLOSED]: [STATE_CLOSED, STATE_MONITORING],\n  [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, STATE_CLOSING],\n  [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, STATE_CLOSING]\n});\nconst INVALID_REQUEST_CHECK_STATES = new Set([STATE_CLOSING, STATE_CLOSED, STATE_MONITORING]);\n\nclass Monitor extends EventEmitter {\n  constructor(server, options) {\n    super(options);\n    this[kServer] = server;\n    this[kConnection] = undefined;\n    this[kCancellationToken] = new EventEmitter();\n    this[kCancellationToken].setMaxListeners(Infinity);\n    this.s = {\n      state: STATE_CLOSED\n    };\n    this.address = server.description.address;\n    this.options = Object.freeze({\n      connectTimeoutMS: typeof options.connectionTimeout === 'number' ? options.connectionTimeout : typeof options.connectTimeoutMS === 'number' ? options.connectTimeoutMS : 10000,\n      heartbeatFrequencyMS: typeof options.heartbeatFrequencyMS === 'number' ? options.heartbeatFrequencyMS : 10000,\n      minHeartbeatFrequencyMS: typeof options.minHeartbeatFrequencyMS === 'number' ? options.minHeartbeatFrequencyMS : 500\n    }); // TODO: refactor this to pull it directly from the pool, requires new ConnectionPool integration\n\n    const addressParts = server.description.address.split(':');\n    this.connectOptions = Object.freeze(Object.assign({\n      id: '<monitor>',\n      host: addressParts[0],\n      port: parseInt(addressParts[1], 10),\n      bson: server.s.bson,\n      connectionType: Connection\n    }, server.s.options, this.options, // force BSON serialization options\n    {\n      raw: false,\n      promoteLongs: true,\n      promoteValues: true,\n      promoteBuffers: true\n    }));\n  }\n\n  connect() {\n    if (this.s.state !== STATE_CLOSED) {\n      return;\n    }\n\n    monitorServer(this);\n  }\n\n  requestCheck() {\n    if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {\n      return;\n    }\n\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    const remainingTime = heartbeatFrequencyMS - calculateDurationInMs(this[kLastCheckTime]);\n\n    if (remainingTime > minHeartbeatFrequencyMS && this[kMonitorId]) {\n      clearTimeout(this[kMonitorId]);\n      rescheduleMonitoring(this, minHeartbeatFrequencyMS);\n      return;\n    }\n\n    if (this[kMonitorId]) {\n      clearTimeout(this[kMonitorId]);\n    }\n\n    monitorServer(this);\n  }\n\n  close() {\n    if (this.s.state === STATE_CLOSED || this.s.state === STATE_CLOSING) {\n      return;\n    }\n\n    stateTransition(this, STATE_CLOSING);\n    this[kCancellationToken].emit('cancel');\n\n    if (this[kMonitorId]) {\n      clearTimeout(this[kMonitorId]);\n    }\n\n    if (this[kConnection]) {\n      this[kConnection].destroy({\n        force: true\n      });\n    }\n\n    this.emit('close');\n    stateTransition(this, STATE_CLOSED);\n  }\n\n}\n\nfunction checkServer(monitor, callback) {\n  if (monitor[kConnection] && monitor[kConnection].closed) {\n    monitor[kConnection] = undefined;\n  }\n\n  const start = process.hrtime();\n  monitor.emit('serverHeartbeatStarted', new ServerHeartbeatStartedEvent(monitor.address));\n\n  function failureHandler(err) {\n    monitor.emit('serverHeartbeatFailed', new ServerHeartbeatFailedEvent(calculateDurationInMs(start), err, monitor.address));\n    callback(err);\n  }\n\n  function successHandler(isMaster) {\n    monitor.emit('serverHeartbeatSucceeded', new ServerHeartbeatSucceededEvent(calculateDurationInMs(start), isMaster, monitor.address));\n    return callback(undefined, isMaster);\n  }\n\n  if (monitor[kConnection] != null) {\n    const connectTimeoutMS = monitor.options.connectTimeoutMS;\n    monitor[kConnection].command('admin.$cmd', {\n      ismaster: true\n    }, {\n      socketTimeout: connectTimeoutMS\n    }, (err, result) => {\n      if (err) {\n        failureHandler(err);\n        return;\n      }\n\n      successHandler(result.result);\n    });\n    return;\n  } // connecting does an implicit `ismaster`\n\n\n  connect(monitor.connectOptions, monitor[kCancellationToken], (err, conn) => {\n    if (err) {\n      monitor[kConnection] = undefined;\n      failureHandler(err);\n      return;\n    }\n\n    if (monitor.s.state === STATE_CLOSING || monitor.s.state === STATE_CLOSED) {\n      conn.destroy({\n        force: true\n      });\n      failureHandler(new MongoError('monitor was destroyed'));\n      return;\n    }\n\n    monitor[kConnection] = conn;\n    successHandler(conn.ismaster);\n  });\n}\n\nfunction monitorServer(monitor) {\n  stateTransition(monitor, STATE_MONITORING); // TODO: the next line is a legacy event, remove in v4\n\n  process.nextTick(() => monitor.emit('monitoring', monitor[kServer]));\n  checkServer(monitor, e0 => {\n    if (e0 == null) {\n      rescheduleMonitoring(monitor);\n      return;\n    } // otherwise an error occured on initial discovery, also bail\n\n\n    if (monitor[kServer].description.type === ServerType.Unknown) {\n      monitor.emit('resetServer', e0);\n      rescheduleMonitoring(monitor);\n      return;\n    } // According to the SDAM specification's \"Network error during server check\" section, if\n    // an ismaster call fails we reset the server's pool. If a server was once connected,\n    // change its type to `Unknown` only after retrying once.\n\n\n    monitor.emit('resetConnectionPool');\n    checkServer(monitor, e1 => {\n      if (e1) {\n        monitor.emit('resetServer', e1);\n      }\n\n      rescheduleMonitoring(monitor);\n    });\n  });\n}\n\nfunction rescheduleMonitoring(monitor, ms) {\n  const heartbeatFrequencyMS = monitor.options.heartbeatFrequencyMS;\n\n  if (monitor.s.state === STATE_CLOSING || monitor.s.state === STATE_CLOSED) {\n    return;\n  }\n\n  stateTransition(monitor, STATE_IDLE);\n  monitor[kLastCheckTime] = process.hrtime();\n  monitor[kMonitorId] = setTimeout(() => {\n    monitor[kMonitorId] = undefined;\n    monitor.requestCheck();\n  }, ms || heartbeatFrequencyMS);\n}\n\nmodule.exports = {\n  Monitor\n};","map":{"version":3,"sources":["/home/rgukt/Projects/covid-19/node_modules/mongodb/lib/core/sdam/monitor.js"],"names":["ServerType","require","calculateDurationInMs","EventEmitter","connect","Connection","common","makeStateMachine","MongoError","sdamEvents","ServerHeartbeatStartedEvent","ServerHeartbeatSucceededEvent","ServerHeartbeatFailedEvent","kServer","Symbol","kMonitorId","kConnection","kCancellationToken","kLastCheckTime","STATE_CLOSED","STATE_CLOSING","STATE_IDLE","STATE_MONITORING","stateTransition","INVALID_REQUEST_CHECK_STATES","Set","Monitor","constructor","server","options","undefined","setMaxListeners","Infinity","s","state","address","description","Object","freeze","connectTimeoutMS","connectionTimeout","heartbeatFrequencyMS","minHeartbeatFrequencyMS","addressParts","split","connectOptions","assign","id","host","port","parseInt","bson","connectionType","raw","promoteLongs","promoteValues","promoteBuffers","monitorServer","requestCheck","has","remainingTime","clearTimeout","rescheduleMonitoring","close","emit","destroy","force","checkServer","monitor","callback","closed","start","process","hrtime","failureHandler","err","successHandler","isMaster","command","ismaster","socketTimeout","result","conn","nextTick","e0","type","Unknown","e1","ms","setTimeout","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst ServerType = require('./common').ServerType;\nconst calculateDurationInMs = require('../utils').calculateDurationInMs;\nconst EventEmitter = require('events');\nconst connect = require('../connection/connect');\nconst Connection = require('../../cmap/connection').Connection;\nconst common = require('./common');\nconst makeStateMachine = require('../utils').makeStateMachine;\nconst MongoError = require('../error').MongoError;\n\nconst sdamEvents = require('./events');\nconst ServerHeartbeatStartedEvent = sdamEvents.ServerHeartbeatStartedEvent;\nconst ServerHeartbeatSucceededEvent = sdamEvents.ServerHeartbeatSucceededEvent;\nconst ServerHeartbeatFailedEvent = sdamEvents.ServerHeartbeatFailedEvent;\n\nconst kServer = Symbol('server');\nconst kMonitorId = Symbol('monitorId');\nconst kConnection = Symbol('connection');\nconst kCancellationToken = Symbol('cancellationToken');\nconst kLastCheckTime = Symbol('lastCheckTime');\n\nconst STATE_CLOSED = common.STATE_CLOSED;\nconst STATE_CLOSING = common.STATE_CLOSING;\nconst STATE_IDLE = 'idle';\nconst STATE_MONITORING = 'monitoring';\nconst stateTransition = makeStateMachine({\n  [STATE_CLOSING]: [STATE_CLOSING, STATE_CLOSED],\n  [STATE_CLOSED]: [STATE_CLOSED, STATE_MONITORING],\n  [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, STATE_CLOSING],\n  [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, STATE_CLOSING]\n});\n\nconst INVALID_REQUEST_CHECK_STATES = new Set([STATE_CLOSING, STATE_CLOSED, STATE_MONITORING]);\n\nclass Monitor extends EventEmitter {\n  constructor(server, options) {\n    super(options);\n\n    this[kServer] = server;\n    this[kConnection] = undefined;\n    this[kCancellationToken] = new EventEmitter();\n    this[kCancellationToken].setMaxListeners(Infinity);\n    this.s = {\n      state: STATE_CLOSED\n    };\n\n    this.address = server.description.address;\n    this.options = Object.freeze({\n      connectTimeoutMS:\n        typeof options.connectionTimeout === 'number'\n          ? options.connectionTimeout\n          : typeof options.connectTimeoutMS === 'number'\n          ? options.connectTimeoutMS\n          : 10000,\n      heartbeatFrequencyMS:\n        typeof options.heartbeatFrequencyMS === 'number' ? options.heartbeatFrequencyMS : 10000,\n      minHeartbeatFrequencyMS:\n        typeof options.minHeartbeatFrequencyMS === 'number' ? options.minHeartbeatFrequencyMS : 500\n    });\n\n    // TODO: refactor this to pull it directly from the pool, requires new ConnectionPool integration\n    const addressParts = server.description.address.split(':');\n    this.connectOptions = Object.freeze(\n      Object.assign(\n        {\n          id: '<monitor>',\n          host: addressParts[0],\n          port: parseInt(addressParts[1], 10),\n          bson: server.s.bson,\n          connectionType: Connection\n        },\n        server.s.options,\n        this.options,\n\n        // force BSON serialization options\n        {\n          raw: false,\n          promoteLongs: true,\n          promoteValues: true,\n          promoteBuffers: true\n        }\n      )\n    );\n  }\n\n  connect() {\n    if (this.s.state !== STATE_CLOSED) {\n      return;\n    }\n\n    monitorServer(this);\n  }\n\n  requestCheck() {\n    if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {\n      return;\n    }\n\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    const remainingTime = heartbeatFrequencyMS - calculateDurationInMs(this[kLastCheckTime]);\n    if (remainingTime > minHeartbeatFrequencyMS && this[kMonitorId]) {\n      clearTimeout(this[kMonitorId]);\n      rescheduleMonitoring(this, minHeartbeatFrequencyMS);\n      return;\n    }\n\n    if (this[kMonitorId]) {\n      clearTimeout(this[kMonitorId]);\n    }\n\n    monitorServer(this);\n  }\n\n  close() {\n    if (this.s.state === STATE_CLOSED || this.s.state === STATE_CLOSING) {\n      return;\n    }\n\n    stateTransition(this, STATE_CLOSING);\n    this[kCancellationToken].emit('cancel');\n    if (this[kMonitorId]) {\n      clearTimeout(this[kMonitorId]);\n    }\n\n    if (this[kConnection]) {\n      this[kConnection].destroy({ force: true });\n    }\n\n    this.emit('close');\n    stateTransition(this, STATE_CLOSED);\n  }\n}\n\nfunction checkServer(monitor, callback) {\n  if (monitor[kConnection] && monitor[kConnection].closed) {\n    monitor[kConnection] = undefined;\n  }\n\n  const start = process.hrtime();\n  monitor.emit('serverHeartbeatStarted', new ServerHeartbeatStartedEvent(monitor.address));\n\n  function failureHandler(err) {\n    monitor.emit(\n      'serverHeartbeatFailed',\n      new ServerHeartbeatFailedEvent(calculateDurationInMs(start), err, monitor.address)\n    );\n\n    callback(err);\n  }\n\n  function successHandler(isMaster) {\n    monitor.emit(\n      'serverHeartbeatSucceeded',\n      new ServerHeartbeatSucceededEvent(calculateDurationInMs(start), isMaster, monitor.address)\n    );\n\n    return callback(undefined, isMaster);\n  }\n\n  if (monitor[kConnection] != null) {\n    const connectTimeoutMS = monitor.options.connectTimeoutMS;\n    monitor[kConnection].command(\n      'admin.$cmd',\n      { ismaster: true },\n      { socketTimeout: connectTimeoutMS },\n      (err, result) => {\n        if (err) {\n          failureHandler(err);\n          return;\n        }\n\n        successHandler(result.result);\n      }\n    );\n\n    return;\n  }\n\n  // connecting does an implicit `ismaster`\n  connect(monitor.connectOptions, monitor[kCancellationToken], (err, conn) => {\n    if (err) {\n      monitor[kConnection] = undefined;\n      failureHandler(err);\n      return;\n    }\n\n    if (monitor.s.state === STATE_CLOSING || monitor.s.state === STATE_CLOSED) {\n      conn.destroy({ force: true });\n      failureHandler(new MongoError('monitor was destroyed'));\n      return;\n    }\n\n    monitor[kConnection] = conn;\n    successHandler(conn.ismaster);\n  });\n}\n\nfunction monitorServer(monitor) {\n  stateTransition(monitor, STATE_MONITORING);\n\n  // TODO: the next line is a legacy event, remove in v4\n  process.nextTick(() => monitor.emit('monitoring', monitor[kServer]));\n\n  checkServer(monitor, e0 => {\n    if (e0 == null) {\n      rescheduleMonitoring(monitor);\n      return;\n    }\n\n    // otherwise an error occured on initial discovery, also bail\n    if (monitor[kServer].description.type === ServerType.Unknown) {\n      monitor.emit('resetServer', e0);\n      rescheduleMonitoring(monitor);\n      return;\n    }\n\n    // According to the SDAM specification's \"Network error during server check\" section, if\n    // an ismaster call fails we reset the server's pool. If a server was once connected,\n    // change its type to `Unknown` only after retrying once.\n    monitor.emit('resetConnectionPool');\n\n    checkServer(monitor, e1 => {\n      if (e1) {\n        monitor.emit('resetServer', e1);\n      }\n\n      rescheduleMonitoring(monitor);\n    });\n  });\n}\n\nfunction rescheduleMonitoring(monitor, ms) {\n  const heartbeatFrequencyMS = monitor.options.heartbeatFrequencyMS;\n  if (monitor.s.state === STATE_CLOSING || monitor.s.state === STATE_CLOSED) {\n    return;\n  }\n\n  stateTransition(monitor, STATE_IDLE);\n\n  monitor[kLastCheckTime] = process.hrtime();\n  monitor[kMonitorId] = setTimeout(() => {\n    monitor[kMonitorId] = undefined;\n    monitor.requestCheck();\n  }, ms || heartbeatFrequencyMS);\n}\n\nmodule.exports = {\n  Monitor\n};\n"]},"metadata":{},"sourceType":"script"}