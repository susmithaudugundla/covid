{"ast":null,"code":"'use strict';\n\nconst ServerType = require('./common').ServerType;\n\nconst TopologyType = require('./common').TopologyType;\n\nconst ReadPreference = require('../topologies/read_preference');\n\nconst MongoError = require('../error').MongoError; // max staleness constants\n\n\nconst IDLE_WRITE_PERIOD = 10000;\nconst SMALLEST_MAX_STALENESS_SECONDS = 90;\n/**\n * Returns a server selector that selects for writable servers\n */\n\nfunction writableServerSelector() {\n  return function (topologyDescription, servers) {\n    return latencyWindowReducer(topologyDescription, servers.filter(s => s.isWritable));\n  };\n}\n/**\n * Reduces the passed in array of servers by the rules of the \"Max Staleness\" specification\n * found here: https://github.com/mongodb/specifications/blob/master/source/max-staleness/max-staleness.rst\n *\n * @param {ReadPreference} readPreference The read preference providing max staleness guidance\n * @param {topologyDescription} topologyDescription The topology description\n * @param {ServerDescription[]} servers The list of server descriptions to be reduced\n * @return {ServerDescription[]} The list of servers that satisfy the requirements of max staleness\n */\n\n\nfunction maxStalenessReducer(readPreference, topologyDescription, servers) {\n  if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {\n    return servers;\n  }\n\n  const maxStaleness = readPreference.maxStalenessSeconds;\n  const maxStalenessVariance = (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1000;\n\n  if (maxStaleness < maxStalenessVariance) {\n    throw new MongoError(`maxStalenessSeconds must be at least ${maxStalenessVariance} seconds`);\n  }\n\n  if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {\n    throw new MongoError(`maxStalenessSeconds must be at least ${SMALLEST_MAX_STALENESS_SECONDS} seconds`);\n  }\n\n  if (topologyDescription.type === TopologyType.ReplicaSetWithPrimary) {\n    const primary = servers.filter(primaryFilter)[0];\n    return servers.reduce((result, server) => {\n      const stalenessMS = server.lastUpdateTime - server.lastWriteDate - (primary.lastUpdateTime - primary.lastWriteDate) + topologyDescription.heartbeatFrequencyMS;\n      const staleness = stalenessMS / 1000;\n      if (staleness <= readPreference.maxStalenessSeconds) result.push(server);\n      return result;\n    }, []);\n  } else if (topologyDescription.type === TopologyType.ReplicaSetNoPrimary) {\n    const sMax = servers.reduce((max, s) => s.lastWriteDate > max.lastWriteDate ? s : max);\n    return servers.reduce((result, server) => {\n      const stalenessMS = sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;\n      const staleness = stalenessMS / 1000;\n      if (staleness <= readPreference.maxStalenessSeconds) result.push(server);\n      return result;\n    }, []);\n  }\n\n  return servers;\n}\n/**\n * Determines whether a server's tags match a given set of tags\n *\n * @param {String[]} tagSet The requested tag set to match\n * @param {String[]} serverTags The server's tags\n */\n\n\nfunction tagSetMatch(tagSet, serverTags) {\n  const keys = Object.keys(tagSet);\n  const serverTagKeys = Object.keys(serverTags);\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n\n    if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Reduces a set of server descriptions based on tags requested by the read preference\n *\n * @param {ReadPreference} readPreference The read preference providing the requested tags\n * @param {ServerDescription[]} servers The list of server descriptions to reduce\n * @return {ServerDescription[]} The list of servers matching the requested tags\n */\n\n\nfunction tagSetReducer(readPreference, servers) {\n  if (readPreference.tags == null || Array.isArray(readPreference.tags) && readPreference.tags.length === 0) {\n    return servers;\n  }\n\n  for (let i = 0; i < readPreference.tags.length; ++i) {\n    const tagSet = readPreference.tags[i];\n    const serversMatchingTagset = servers.reduce((matched, server) => {\n      if (tagSetMatch(tagSet, server.tags)) matched.push(server);\n      return matched;\n    }, []);\n\n    if (serversMatchingTagset.length) {\n      return serversMatchingTagset;\n    }\n  }\n\n  return [];\n}\n/**\n * Reduces a list of servers to ensure they fall within an acceptable latency window. This is\n * further specified in the \"Server Selection\" specification, found here:\n * https://github.com/mongodb/specifications/blob/master/source/server-selection/server-selection.rst\n *\n * @param {topologyDescription} topologyDescription The topology description\n * @param {ServerDescription[]} servers The list of servers to reduce\n * @returns {ServerDescription[]} The servers which fall within an acceptable latency window\n */\n\n\nfunction latencyWindowReducer(topologyDescription, servers) {\n  const low = servers.reduce((min, server) => min === -1 ? server.roundTripTime : Math.min(server.roundTripTime, min), -1);\n  const high = low + topologyDescription.localThresholdMS;\n  return servers.reduce((result, server) => {\n    if (server.roundTripTime <= high && server.roundTripTime >= low) result.push(server);\n    return result;\n  }, []);\n} // filters\n\n\nfunction primaryFilter(server) {\n  return server.type === ServerType.RSPrimary;\n}\n\nfunction secondaryFilter(server) {\n  return server.type === ServerType.RSSecondary;\n}\n\nfunction nearestFilter(server) {\n  return server.type === ServerType.RSSecondary || server.type === ServerType.RSPrimary;\n}\n\nfunction knownFilter(server) {\n  return server.type !== ServerType.Unknown;\n}\n/**\n * Returns a function which selects servers based on a provided read preference\n *\n * @param {ReadPreference} readPreference The read preference to select with\n */\n\n\nfunction readPreferenceServerSelector(readPreference) {\n  if (!readPreference.isValid()) {\n    throw new TypeError('Invalid read preference specified');\n  }\n\n  return function (topologyDescription, servers) {\n    const commonWireVersion = topologyDescription.commonWireVersion;\n\n    if (commonWireVersion && readPreference.minWireVersion && readPreference.minWireVersion > commonWireVersion) {\n      throw new MongoError(`Minimum wire version '${readPreference.minWireVersion}' required, but found '${commonWireVersion}'`);\n    }\n\n    if (topologyDescription.type === TopologyType.Unknown) {\n      return [];\n    }\n\n    if (topologyDescription.type === TopologyType.Single || topologyDescription.type === TopologyType.Sharded) {\n      return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));\n    }\n\n    if (readPreference.mode === ReadPreference.PRIMARY) {\n      return servers.filter(primaryFilter);\n    }\n\n    if (readPreference.mode === ReadPreference.SECONDARY) {\n      return latencyWindowReducer(topologyDescription, tagSetReducer(readPreference, maxStalenessReducer(readPreference, topologyDescription, servers))).filter(secondaryFilter);\n    } else if (readPreference.mode === ReadPreference.NEAREST) {\n      return latencyWindowReducer(topologyDescription, tagSetReducer(readPreference, maxStalenessReducer(readPreference, topologyDescription, servers))).filter(nearestFilter);\n    } else if (readPreference.mode === ReadPreference.SECONDARY_PREFERRED) {\n      const result = latencyWindowReducer(topologyDescription, tagSetReducer(readPreference, maxStalenessReducer(readPreference, topologyDescription, servers))).filter(secondaryFilter);\n      return result.length === 0 ? servers.filter(primaryFilter) : result;\n    } else if (readPreference.mode === ReadPreference.PRIMARY_PREFERRED) {\n      const result = servers.filter(primaryFilter);\n\n      if (result.length) {\n        return result;\n      }\n\n      return latencyWindowReducer(topologyDescription, tagSetReducer(readPreference, maxStalenessReducer(readPreference, topologyDescription, servers))).filter(secondaryFilter);\n    }\n  };\n}\n\nmodule.exports = {\n  writableServerSelector,\n  readPreferenceServerSelector\n};","map":{"version":3,"sources":["/home/rgukt/Projects/covid-19/node_modules/mongodb/lib/core/sdam/server_selection.js"],"names":["ServerType","require","TopologyType","ReadPreference","MongoError","IDLE_WRITE_PERIOD","SMALLEST_MAX_STALENESS_SECONDS","writableServerSelector","topologyDescription","servers","latencyWindowReducer","filter","s","isWritable","maxStalenessReducer","readPreference","maxStalenessSeconds","maxStaleness","maxStalenessVariance","heartbeatFrequencyMS","type","ReplicaSetWithPrimary","primary","primaryFilter","reduce","result","server","stalenessMS","lastUpdateTime","lastWriteDate","staleness","push","ReplicaSetNoPrimary","sMax","max","tagSetMatch","tagSet","serverTags","keys","Object","serverTagKeys","i","length","key","indexOf","tagSetReducer","tags","Array","isArray","serversMatchingTagset","matched","low","min","roundTripTime","Math","high","localThresholdMS","RSPrimary","secondaryFilter","RSSecondary","nearestFilter","knownFilter","Unknown","readPreferenceServerSelector","isValid","TypeError","commonWireVersion","minWireVersion","Single","Sharded","mode","PRIMARY","SECONDARY","NEAREST","SECONDARY_PREFERRED","PRIMARY_PREFERRED","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst ServerType = require('./common').ServerType;\nconst TopologyType = require('./common').TopologyType;\nconst ReadPreference = require('../topologies/read_preference');\nconst MongoError = require('../error').MongoError;\n\n// max staleness constants\nconst IDLE_WRITE_PERIOD = 10000;\nconst SMALLEST_MAX_STALENESS_SECONDS = 90;\n\n/**\n * Returns a server selector that selects for writable servers\n */\nfunction writableServerSelector() {\n  return function(topologyDescription, servers) {\n    return latencyWindowReducer(\n      topologyDescription,\n      servers.filter(s => s.isWritable)\n    );\n  };\n}\n\n/**\n * Reduces the passed in array of servers by the rules of the \"Max Staleness\" specification\n * found here: https://github.com/mongodb/specifications/blob/master/source/max-staleness/max-staleness.rst\n *\n * @param {ReadPreference} readPreference The read preference providing max staleness guidance\n * @param {topologyDescription} topologyDescription The topology description\n * @param {ServerDescription[]} servers The list of server descriptions to be reduced\n * @return {ServerDescription[]} The list of servers that satisfy the requirements of max staleness\n */\nfunction maxStalenessReducer(readPreference, topologyDescription, servers) {\n  if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {\n    return servers;\n  }\n\n  const maxStaleness = readPreference.maxStalenessSeconds;\n  const maxStalenessVariance =\n    (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1000;\n  if (maxStaleness < maxStalenessVariance) {\n    throw new MongoError(`maxStalenessSeconds must be at least ${maxStalenessVariance} seconds`);\n  }\n\n  if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {\n    throw new MongoError(\n      `maxStalenessSeconds must be at least ${SMALLEST_MAX_STALENESS_SECONDS} seconds`\n    );\n  }\n\n  if (topologyDescription.type === TopologyType.ReplicaSetWithPrimary) {\n    const primary = servers.filter(primaryFilter)[0];\n    return servers.reduce((result, server) => {\n      const stalenessMS =\n        server.lastUpdateTime -\n        server.lastWriteDate -\n        (primary.lastUpdateTime - primary.lastWriteDate) +\n        topologyDescription.heartbeatFrequencyMS;\n\n      const staleness = stalenessMS / 1000;\n      if (staleness <= readPreference.maxStalenessSeconds) result.push(server);\n      return result;\n    }, []);\n  } else if (topologyDescription.type === TopologyType.ReplicaSetNoPrimary) {\n    const sMax = servers.reduce((max, s) => (s.lastWriteDate > max.lastWriteDate ? s : max));\n    return servers.reduce((result, server) => {\n      const stalenessMS =\n        sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;\n\n      const staleness = stalenessMS / 1000;\n      if (staleness <= readPreference.maxStalenessSeconds) result.push(server);\n      return result;\n    }, []);\n  }\n\n  return servers;\n}\n\n/**\n * Determines whether a server's tags match a given set of tags\n *\n * @param {String[]} tagSet The requested tag set to match\n * @param {String[]} serverTags The server's tags\n */\nfunction tagSetMatch(tagSet, serverTags) {\n  const keys = Object.keys(tagSet);\n  const serverTagKeys = Object.keys(serverTags);\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Reduces a set of server descriptions based on tags requested by the read preference\n *\n * @param {ReadPreference} readPreference The read preference providing the requested tags\n * @param {ServerDescription[]} servers The list of server descriptions to reduce\n * @return {ServerDescription[]} The list of servers matching the requested tags\n */\nfunction tagSetReducer(readPreference, servers) {\n  if (\n    readPreference.tags == null ||\n    (Array.isArray(readPreference.tags) && readPreference.tags.length === 0)\n  ) {\n    return servers;\n  }\n\n  for (let i = 0; i < readPreference.tags.length; ++i) {\n    const tagSet = readPreference.tags[i];\n    const serversMatchingTagset = servers.reduce((matched, server) => {\n      if (tagSetMatch(tagSet, server.tags)) matched.push(server);\n      return matched;\n    }, []);\n\n    if (serversMatchingTagset.length) {\n      return serversMatchingTagset;\n    }\n  }\n\n  return [];\n}\n\n/**\n * Reduces a list of servers to ensure they fall within an acceptable latency window. This is\n * further specified in the \"Server Selection\" specification, found here:\n * https://github.com/mongodb/specifications/blob/master/source/server-selection/server-selection.rst\n *\n * @param {topologyDescription} topologyDescription The topology description\n * @param {ServerDescription[]} servers The list of servers to reduce\n * @returns {ServerDescription[]} The servers which fall within an acceptable latency window\n */\nfunction latencyWindowReducer(topologyDescription, servers) {\n  const low = servers.reduce(\n    (min, server) => (min === -1 ? server.roundTripTime : Math.min(server.roundTripTime, min)),\n    -1\n  );\n\n  const high = low + topologyDescription.localThresholdMS;\n\n  return servers.reduce((result, server) => {\n    if (server.roundTripTime <= high && server.roundTripTime >= low) result.push(server);\n    return result;\n  }, []);\n}\n\n// filters\nfunction primaryFilter(server) {\n  return server.type === ServerType.RSPrimary;\n}\n\nfunction secondaryFilter(server) {\n  return server.type === ServerType.RSSecondary;\n}\n\nfunction nearestFilter(server) {\n  return server.type === ServerType.RSSecondary || server.type === ServerType.RSPrimary;\n}\n\nfunction knownFilter(server) {\n  return server.type !== ServerType.Unknown;\n}\n\n/**\n * Returns a function which selects servers based on a provided read preference\n *\n * @param {ReadPreference} readPreference The read preference to select with\n */\nfunction readPreferenceServerSelector(readPreference) {\n  if (!readPreference.isValid()) {\n    throw new TypeError('Invalid read preference specified');\n  }\n\n  return function(topologyDescription, servers) {\n    const commonWireVersion = topologyDescription.commonWireVersion;\n    if (\n      commonWireVersion &&\n      readPreference.minWireVersion &&\n      readPreference.minWireVersion > commonWireVersion\n    ) {\n      throw new MongoError(\n        `Minimum wire version '${readPreference.minWireVersion}' required, but found '${commonWireVersion}'`\n      );\n    }\n\n    if (topologyDescription.type === TopologyType.Unknown) {\n      return [];\n    }\n\n    if (\n      topologyDescription.type === TopologyType.Single ||\n      topologyDescription.type === TopologyType.Sharded\n    ) {\n      return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));\n    }\n\n    if (readPreference.mode === ReadPreference.PRIMARY) {\n      return servers.filter(primaryFilter);\n    }\n\n    if (readPreference.mode === ReadPreference.SECONDARY) {\n      return latencyWindowReducer(\n        topologyDescription,\n        tagSetReducer(\n          readPreference,\n          maxStalenessReducer(readPreference, topologyDescription, servers)\n        )\n      ).filter(secondaryFilter);\n    } else if (readPreference.mode === ReadPreference.NEAREST) {\n      return latencyWindowReducer(\n        topologyDescription,\n        tagSetReducer(\n          readPreference,\n          maxStalenessReducer(readPreference, topologyDescription, servers)\n        )\n      ).filter(nearestFilter);\n    } else if (readPreference.mode === ReadPreference.SECONDARY_PREFERRED) {\n      const result = latencyWindowReducer(\n        topologyDescription,\n        tagSetReducer(\n          readPreference,\n          maxStalenessReducer(readPreference, topologyDescription, servers)\n        )\n      ).filter(secondaryFilter);\n\n      return result.length === 0 ? servers.filter(primaryFilter) : result;\n    } else if (readPreference.mode === ReadPreference.PRIMARY_PREFERRED) {\n      const result = servers.filter(primaryFilter);\n      if (result.length) {\n        return result;\n      }\n\n      return latencyWindowReducer(\n        topologyDescription,\n        tagSetReducer(\n          readPreference,\n          maxStalenessReducer(readPreference, topologyDescription, servers)\n        )\n      ).filter(secondaryFilter);\n    }\n  };\n}\n\nmodule.exports = {\n  writableServerSelector,\n  readPreferenceServerSelector\n};\n"]},"metadata":{},"sourceType":"script"}